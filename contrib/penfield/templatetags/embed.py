from django import template
from django.contrib.contenttypes.models import ContentType
from django.conf import settings
from philo.utils import LOADED_TEMPLATE_ATTR


register = template.Library()


class EmbedNode(template.Node):
	def __init__(self, content_type, varname, object_pk=None, template_name=None):
		assert template_name is not None or object_pk is not None
		self.content_type = content_type
		self.varname = varname
		
		if object_pk is not None:
			self.object_pk = object_pk
			try:
				self.instance = content_type.get_object_for_this_type(pk=object_pk)
			except content_type.model_class().DoesNotExist:
				self.instance = False
		else:
			self.instance = None
		
		if template_name is not None:
			try:
				self.template = template.loader.get_template(template_name)
			except template.TemplateDoesNotExist:
				self.template = False
		else:
			self.template = None
	
	def render(self, context):
		if self.template_name is not None:
			if self.template is False:
				return settings.TEMPLATE_STRING_IF_INVALID
			
			if self.varname not in context:
				context[self.varname] = {}
			context[self.varname][self.content_type] = self.template
			
			return ''
		
		# Otherwise self.instance should be set. Render the instance with the appropriate template!
		if self.instance is None or self.instance is False:
			return settings.TEMPLATE_STRING_IF_INVALID
		
		try:
			t = context[self.varname][self.content_type]
		except KeyError:
			return settings.TEMPLATE_STRING_IF_INVALID
		
		context.push()
		context['embedded'] = self.instance
		t_rendered = t.render(context)
		context.pop()
		return t_rendered


def get_embedded(self):
	return template.loader.get_template(self.template_name)


setattr(EmbedNode, LOADED_TEMPLATE_ATTR, property(get_embedded))


def do_embed(parser, token):
	"""
	The {% embed %} tag can be used in three ways:
	{% embed as <varname> %} :: This sets which variable will be used to track embedding template names for the current context. Default: "embed"
	{% embed <app_label>.<model_name> with <template> %} :: Sets which template will be used to render a particular model.
	{% embed <app_label>.<model_name> <object_pk> %} :: Embeds the instance specified by the given parameters in the document with the previously-specified template.
	"""
	args = token.split_contents()
	tag = args[0]
	
	if len(args) < 2:
		raise template.TemplateSyntaxError('"%s" template tag must have at least three arguments.' % tag)
	elif len(args) > 4:
		raise template.TemplateSyntaxError('"%s" template tag may have no more than four arguments.' % tag)
	else:
		if len(args) == 3 and args[1] == "as":
			parser._embedNodeVarName = args[2]
			return template.defaulttags.CommentNode()
		
		if '.' not in args[1]:
			raise template.TemplateSyntaxError('"%s" template tag expects the first argument to be of the form app_label.model' % tag)
		
		app_label, model = args[1].split('.')
		try:
			ct = ContentType.objects.get(app_label=app_label, model=model)
		except ContentType.DoesNotExist:
			raise template.TemplateSyntaxError('"%s" template tag option "references" requires an argument of the form app_label.model which refers to an installed content type (see django.contrib.contenttypes)' % tag)
		
		if len(args) == 3:
			
			return EmbedNode(ct, object_pk=args[2], varname=getattr(parser, '_embedNodeVarName', 'embed'))
		else:
			# 3 args
			if args[2] != "with":
				raise template.TemplateSyntaxError('"%s" template tag requires the second of three arguments to be "with"' % tag)
			
			if args[3][0] not in ['"', "'"] and args[3][-1] not in ['"', "'"]:
				raise template.TemplateSyntaxError('"%s" template tag expects the template name to be in quotes.' % tag)
			if args[3][0] != args[3][-1]:
				raise template.TemplateSyntaxError('"%s" template tag called with non-matching quotes.' % tag)
			
			template_name = args[3].strip('"\'')
			
			return EmbedNode(ct, template_name=template_name, varname=getattr(parser, '_embedNodeVarName', 'embed'))


register.tag('embed', do_embed)